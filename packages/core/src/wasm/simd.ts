/**
 * @fileoverview Provides the histogram accumulator used when the runtime is
 *   configured for "simd" mode. The module attempts to load the Rust + wasm
 *   helpers generated by `wasm-pack`; if that fails (missing build artifacts or
 *   unsupported environment) it falls back to a pure TypeScript implementation
 *   that mirrors the prior behaviour. The exported factory remains synchronous
 *   so existing worker code can continue to construct the accumulator without
 *   awaiting module initialisation.
 */

import type { HistogramView } from '../memory/layout';

type Delta = -1 | 1;

type HistogramBindings = {
  init_panic_hook: () => void;
  scratchBuffer: (size: number) => Uint16Array;
  accumulateScratch: (len: number, binCount: number) => Uint32Array;
  accumulateBins: (bins: Uint16Array, binCount: number) => Uint32Array;
  resetMetrics?: () => void;
  takeMetrics?: () => unknown;
};

let wasmInitPromise: Promise<HistogramBindings | null> | null = null;
let wasmBindings: HistogramBindings | null | undefined;
const isNode = Boolean(
  typeof globalThis !== 'undefined' &&
    (globalThis as { process?: { versions?: { node?: string } } }).process?.versions?.node
);

// Chunking keeps very large clears from routing millions of rows through a single
// wasm call. Threshold/size are tuned for a balance between overhead and cache
// locality; they can be revisited as part of future tuning.
const WASM_CHUNK_THRESHOLD = 262_144; // rows
const WASM_CHUNK_SIZE = 131_072;

function requestWasmBindings(): void {
  if (wasmInitPromise) return;
  wasmInitPromise = (async () => {
    try {
      // @ts-ignore - WASM module may not exist if not built
      const module: unknown = await import('./pkg/crossfilterx_kernels.js');
      const anyModule = module as Record<string, unknown>;
      const initialise = typeof anyModule.default === 'function' ? anyModule.default : null;
      const wasmUrl = new URL('./pkg/crossfilterx_kernels_bg.wasm', import.meta.url);
      if (typeof initialise === 'function') {
        if (isNode) {
          // eslint-disable-next-line @typescript-eslint/ban-ts-comment
          // @ts-ignore Node-specific modules loaded dynamically at runtime.
          const [{ readFile }, { fileURLToPath }] = await Promise.all([
            import('node:fs/promises'),
            import('node:url')
          ]);
          const wasmPath = fileURLToPath(wasmUrl);
          const bytes = await readFile(wasmPath);
          const module = await WebAssembly.compile(bytes);
          await (initialise as (input?: unknown) => Promise<unknown>)({ module_or_path: module });
        } else {
          await (initialise as (input?: unknown) => Promise<unknown>)({ module_or_path: wasmUrl });
        }
      }
      const initHook = anyModule.init_panic_hook;
      if (typeof initHook === 'function') {
        (initHook as () => void)();
      }
      const bindings = anyModule as unknown as HistogramBindings;
      wasmBindings = bindings;
      return bindings;
    } catch (error) {
      console.warn('[crossfilterx] wasm histogram kernels unavailable; falling back to JS', error);
      wasmBindings = null;
      return null;
    }
  })();
}

export class HistogramSimdAccumulator {
  private columns: Uint16Array[] = [];
  private histograms: HistogramView[] = [];
  private activations: Uint32Array;
  private deactivations: Uint32Array;
  private activationCount = 0;
  private deactivationCount = 0;
  constructor(initialCapacity = 1_048_576) {
    this.activations = new Uint32Array(initialCapacity);
    this.deactivations = new Uint32Array(initialCapacity);
    requestWasmBindings();
  }

  configure(columns: Uint16Array[], histograms: HistogramView[]) {
    this.columns = columns;
    this.histograms = histograms;
    this.reset();
  }

  record(row: number, delta: Delta) {
    if (delta === 1) {
      this.activations = ensureCapacity(this.activations, this.activationCount + 1);
      this.activations[this.activationCount++] = row;
      return;
    }
    this.deactivations = ensureCapacity(this.deactivations, this.deactivationCount + 1);
    this.deactivations[this.deactivationCount++] = row;
  }

  flush() {
    if (this.activationCount === 0 && this.deactivationCount === 0) {
      return;
    }

    const { columns, histograms } = this;
    if (!columns.length || !histograms.length) {
      this.reset();
      return;
    }

    const wasm = wasmBindings;
    const usedWasm =
      wasm !== undefined && wasm !== null &&
      (this.activationCount > 0 || this.deactivationCount > 0);

    const scratchBase = usedWasm
      ? wasm.scratchBuffer(Math.max(this.activationCount, this.deactivationCount))
      : null;
    const activationScratch = scratchBase ? scratchBase.subarray(0, this.activationCount) : null;
    const deactivationScratch = scratchBase ? scratchBase.subarray(0, this.deactivationCount) : null;

    if (
      usedWasm &&
      applyWithWasm(
        wasm,
        columns,
        histograms,
        this.activations,
        this.activationCount,
        1,
        activationScratch
      )
    ) {
      applyWithWasm(
        wasm,
        columns,
        histograms,
        this.deactivations,
        this.deactivationCount,
        -1,
        deactivationScratch
      );
    } else {
      applyDelta(columns, histograms, this.activations, this.activationCount, 1);
      applyDelta(columns, histograms, this.deactivations, this.deactivationCount, -1);
    }

    this.reset();
  }

  reset() {
    this.activationCount = 0;
    this.deactivationCount = 0;
  }
}

function applyDelta(
  columns: Uint16Array[],
  histograms: HistogramView[],
  rows: Uint32Array,
  count: number,
  delta: Delta
) {
  if (count === 0) return;
  for (let index = 0; index < count; index++) {
    const row = rows[index];
    for (let dim = 0; dim < histograms.length; dim++) {
      const bin = columns[dim][row];
      histograms[dim].front[bin] += delta;
      histograms[dim].back[bin] += delta;
    }
  }
}

function applyWithWasm(
  wasm: HistogramBindings,
  columns: Uint16Array[],
  histograms: HistogramView[],
  rows: Uint32Array,
  count: number,
  delta: Delta,
  scratch: Uint16Array | null
) {
  if (count === 0) return true;
  try {
    if (!scratch) return false;
    if (scratch.length < count) {
      throw new Error('scratch buffer too small');
    }
    const profileShards = shouldProfileShards();
    if (profileShards) {
      (globalThis as Record<string, unknown> & { __CFX_SHARD_PROFILED?: number }).__CFX_SHARD_PROFILED =
        ((globalThis as Record<string, unknown> & { __CFX_SHARD_PROFILED?: number }).__CFX_SHARD_PROFILED ?? 0) +
        1;
    } else {
      (globalThis as Record<string, unknown> & { __CFX_SHARD_SKIPPED?: number }).__CFX_SHARD_SKIPPED =
        ((globalThis as Record<string, unknown> & { __CFX_SHARD_SKIPPED?: number }).__CFX_SHARD_SKIPPED ?? 0) +
        1;
    }
    const now = getNow();
    const slice = rows.subarray(0, count);
    for (let dim = 0; dim < histograms.length; dim++) {
      const column = columns[dim];
      const binCount = histograms[dim].front.length;
      let totalCopy = 0;
      let totalWasm = 0;
      let aggregatedMetrics: unknown = null;
      const chunkSize = Math.max(1, count > WASM_CHUNK_THRESHOLD ? WASM_CHUNK_SIZE : count);
      const iterations = Math.ceil(count / chunkSize);
      for (let iter = 0; iter < iterations; iter++) {
        const offset = iter * chunkSize;
        const span = Math.min(chunkSize, count - offset);
        if (span <= 0) break;
        if (profileShards) {
          const copyStart = now();
          for (let index = 0; index < span; index++) {
            scratch[index] = column[slice[offset + index]];
          }
          totalCopy += now() - copyStart;
        } else {
          for (let index = 0; index < span; index++) {
            scratch[index] = column[slice[offset + index]];
          }
        }
        if (profileShards && typeof wasm.resetMetrics === 'function') {
          wasm.resetMetrics();
        }
        const wasmStart = profileShards ? now() : 0;
        const accum = wasm.accumulateScratch(span, binCount);
        if (profileShards) {
          totalWasm += now() - wasmStart;
        }
        for (let bin = 0; bin < binCount; bin++) {
          const value = accum[bin];
          if (!value) continue;
          const contribution = delta === 1 ? value : -value;
          histograms[dim].front[bin] += contribution;
          histograms[dim].back[bin] += contribution;
        }
        if (profileShards && typeof wasm.takeMetrics === 'function') {
          const metrics = wasm.takeMetrics();
          if (!aggregatedMetrics) {
            aggregatedMetrics = metrics;
          } else {
            mergeShardMetrics(aggregatedMetrics, metrics);
          }
        }
      }
      if (profileShards) {
        recordShardProfile({
          dim,
          delta,
          rows: count,
          copyMs: totalCopy,
          wasmMs: totalWasm,
          metrics: aggregatedMetrics
        });
      }
    }
    return true;
  } catch (error) {
    console.warn('[crossfilterx] wasm histogram apply failed; falling back to JS', error);
    wasmBindings = null;
    return false;
  }
}

function getNow() {
  const perf = (globalThis as { performance?: { now(): number } }).performance;
  if (perf?.now) {
    return () => perf.now();
  }
  const processRef = (globalThis as { process?: { hrtime?: () => [number, number] } }).process;
  const hrtime = processRef?.hrtime;
  if (typeof hrtime === 'function') {
    return () => {
      const [sec, nsec] = hrtime.call(processRef);
      return sec * 1_000 + nsec / 1_000_000;
    };
  }
  return () => Date.now();
}

function recordShardProfile(entry: {
  dim: number;
  delta: Delta;
  rows: number;
  copyMs: number;
  wasmMs: number;
  metrics: unknown;
}) {
  const root = globalThis as Record<string, unknown> & { __CFX_HIST_PROFILE_LOG?: unknown };
  if (!Array.isArray(root.__CFX_HIST_PROFILE_LOG)) {
    root.__CFX_HIST_PROFILE_LOG = [];
  }
  (root.__CFX_HIST_PROFILE_LOG as Array<typeof entry>).push(entry);
}

function mergeShardMetrics(target: unknown, source: unknown) {
  if (!target || !source) return;
  const t = target as Record<string, number>;
  const s = source as Record<string, number>;
  for (const key of Object.keys(s)) {
    if (typeof s[key] !== 'number') continue;
    const current = typeof t[key] === 'number' ? (t[key] as number) : 0;
    t[key] = current + (s[key] as number);
  }
}

function shouldProfileShards(): boolean {
  const root = globalThis as Record<string, unknown> & { __CFX_PROFILE_SHARDS?: unknown };
  if (root.__CFX_PROFILE_SHARDS) {
    return true;
  }
  const env = (globalThis as unknown as { process?: { env?: Record<string, string> } }).process?.env;
  return env?.BENCH_PROFILE_SHARD === '1';
}

function ensureCapacity(array: Uint32Array, required: number) {
  if (required <= array.length) return array;
  const next = new Uint32Array(required * 2);
  next.set(array);
  return next;
}

export function createHistogramSimdAccumulator(columns: Uint16Array[], histograms: HistogramView[]) {
  const accumulator = new HistogramSimdAccumulator();
  accumulator.configure(columns, histograms);
  return accumulator;
}

export async function waitForWasmReady() {
  requestWasmBindings();
  if (!wasmInitPromise) {
    return wasmBindings ?? null;
  }
  try {
    return await wasmInitPromise;
  } catch (error) {
    console.warn('[crossfilterx] wasm histogram init failed', error);
    return null;
  }
}
